# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

Ecash App is a Fedimint wallet built with Flutter for the UI and Rust for the core wallet logic. The Rust code is exposed to Flutter via Flutter Rust Bridge (FRB). The app supports Lightning, On-chain, and Ecash payments, along with features like Lightning Address, Nostr Wallet Connect (NWC), and federation discovery via Nostr.

## Development Environment Setup

This project uses Nix flakes for reproducible builds and dependency management.

1. Install Nix:
```bash
curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install
```

2. Enter the Nix development environment:
```bash
nix develop
```

All subsequent commands must be run within the `nix develop` shell.

## Build Commands

All commands should be prefixed with `nix develop` or run within the nix shell:

- `just generate` - Generate Flutter Rust Bridge bindings and run Flutter codegen
  - Runs `flutter_rust_bridge_codegen` to generate Dart/Rust FFI bindings
  - Runs `flutter pub run build_runner build` for freezed code generation
- `just build-linux` - Build the Rust library for Linux
- `just build-android-x86_64` - Build for Android x86_64
- `just build-android-arm` - Build for Android ARM
- `just build-debug-apk` - Build debug APK using Docker
- `just run` - Run the app on Linux with software rendering

Docker build (reproducible):
- `./docker/build-apk.sh debug` - Build debug APK in Docker
- `CLEAN=1 REBUILD_IMAGE=1 ./docker/build-apk.sh debug` - Clean build with image rebuild

## Architecture

### Rust Core (rust/ecashapp/src/)

The Rust backend handles all Fedimint wallet operations and is organized into:

- **lib.rs** - Entry point with global state management using `OnceCell` for:
  - `MULTIMINT` - Main wallet instance
  - `DATABASE` - RocksDB database
  - `NOSTR` - Nostr client for federation discovery and backup
  - `EVENT_BUS` - Event publishing system for UI updates
  - `RECOVERY_RELAYS` - Nostr relays for backup/recovery

- **multimint.rs** - Core wallet logic (~4000+ lines):
  - `Multimint` struct: Manages multiple federation clients
  - Client lifecycle: Building, caching, and managing Fedimint clients
  - Payment operations: Lightning (LNv1/LNv2), on-chain, ecash
  - Gateway selection and fee computation
  - Background tasks for monitoring payments, deposits, and backups
  - Federation metadata and price caching

- **nostr.rs** - Nostr integration:
  - Federation discovery via Nostr events
  - Backup/recovery of federation invite codes to Nostr
  - Lightning Address registration via Nostr
  - Nostr Wallet Connect (NWC) for external app integrations

- **db.rs** - Database schema and key/value types for RocksDB
- **event_bus.rs** - Event publishing system for UI updates

### Flutter UI (lib/)

- **Main entry points:**
  - `main.dart` - App initialization, database setup, mnemonic handling
  - `app.dart` - Root widget with event subscription, navigation, and global state

- **State management:**
  - Provider pattern for preferences (`providers/preferences_provider.dart`)
  - Event-driven updates via `MultimintEvent` stream from Rust
  - `ValueNotifier` for simple reactive state

- **Key screens:** (screens/)
  - `dashboard.dart` - Main wallet view showing balance and transactions
  - `display_settings.dart` - App settings and preferences

- **Core components:**
  - `multimint.dart` - Auto-generated FRB bindings for Multimint Rust API
  - `lib.dart` - Auto-generated FRB bindings for top-level Rust functions
  - `frb_generated.*.dart` - Flutter Rust Bridge generated code
  - `*.freezed.dart` - Generated by freezed for immutable data classes

- **UI widgets:** (lib/)
  - `fed_preview.dart` - Federation preview and joining
  - `scan.dart` - QR code scanning for payments
  - `sidebar.dart` - Navigation sidebar
  - Payment flows: `request.dart`, `send.dart`, `ecash_send.dart`, `onchain_send.dart`, `onchain_receive.dart`
  - Lightning Address: `ln_address.dart`
  - Nostr Wallet Connect: `nwc.dart`

### Flutter Rust Bridge Integration

The bridge is bidirectional:

**Dart → Rust:** Functions in `lib.rs` and `multimint.rs` marked with `#[frb]` are exposed to Dart
- Example: `create_new_multimint(path: String)` → Dart function in `lib.dart`

**Rust → Dart:** Events via `EventBus` using `StreamSink`
- Rust publishes `MultimintEvent` (Lightning, Ecash, Deposit, Log, Recovery events)
- Dart subscribes via `subscribeMultimintEvents()` stream
- Handled in `app.dart`'s `initState()` for UI updates

When modifying the Rust API:
1. Add/modify functions with `#[frb]` attribute
2. Run `just generate` to regenerate bindings
3. Update Dart code to use new/modified functions

### Database

- **Backend:** RocksDB (via `fedimint_rocksdb`)
- **Location:** `{app_data}/client.db`
- **Schema:** Defined in `rust/ecashapp/src/db.rs`
- **Key patterns:**
  - Federation configs: `FederationConfigKey`, `FederationConfigKeyPrefix`
  - Lightning Address: `LightningAddressKey`, `LightningAddressKeyPrefix`
  - Federation metadata: `FederationMetaKey`
  - BTC price cache: `BtcPriceKey`, `BtcPricesKey`
  - User preferences: `BitcoinDisplayKey`, `FiatCurrencyKey`
  - Seed phrase acknowledgment: `SeedPhraseAckKey`

### Fedimint Integration

The app uses Fedimint SDK v0.9.0 with these modules:
- **fedimint-mint-client** - Ecash mint operations
- **fedimint-ln-client** - Lightning v1 (legacy)
- **fedimint-lnv2-client** - Lightning v2 (preferred for new gateways)
- **fedimint-wallet-client** - On-chain Bitcoin operations
- **fedimint-meta-client** - Federation metadata

Key concepts:
- **Federation:** A mint (set of guardians) users join via invite codes
- **Multimint:** Managing multiple federations in one wallet
- **Gateway:** Lightning node that facilitates Lightning payments for a federation
- **Operation:** Async payment operation tracked by `OperationId`

## Important Patterns

### Error Handling
- Rust functions use `anyhow::Result` and publish errors via `error_to_flutter()`
- Dart catches errors and shows toasts via `ToastService`

### Async Operations
- Payment operations return `OperationId` immediately
- Background tasks monitor operation state changes
- UI subscribes to `MultimintEvent` stream for updates

### Recovery
- Seed phrase (BIP39 mnemonic) derives all keys
- Federation invite codes backed up to Nostr relays
- Recovery progress tracked per federation

## Testing

No test commands are currently defined in the justfile. Manual testing is done by running the app.

## Code Generation

The project uses multiple code generation tools:
1. **flutter_rust_bridge_codegen** - Generates Dart/Rust FFI bindings
2. **build_runner** (freezed) - Generates immutable data classes with pattern matching
3. **flutter_launcher_icons** - Generates app icons

Always run `just generate` after:
- Modifying Rust functions marked with `#[frb]`
- Adding new Rust types exposed to Dart
- Modifying freezed-annotated Dart classes

## Custom Commands & Skills

### Available Slash Commands

- `/generate` - Generate Flutter Rust Bridge bindings and run Flutter codegen (with verification)
- `/build-apk` - Build debug APK using Docker with optional clean build and image rebuild
- `/check-config` - Verify NDK versions, build settings, and dependency consistency across the project
- `/review-rust-api [file-path]` - Review Rust code for proper #[frb] annotations, error handling, and async patterns

### Available Skills (Auto-invoked)

- **fedimint-rust** - Guides Claude on Ecash App's Rust architecture, Fedimint SDK integration, and multimint wallet patterns
- **frb-integration** - Teaches Flutter Rust Bridge bidirectional communication patterns and code generation workflow
- **android-native** - Provides guidance on Android manifest configuration, permissions, intents, and platform channels

Skills are automatically invoked by Claude when relevant to the task. Slash commands require explicit invocation with `/command-name`.
