// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'lib.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$ParsedText {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ParsedText()';
}


}

/// @nodoc
class $ParsedTextCopyWith<$Res>  {
$ParsedTextCopyWith(ParsedText _, $Res Function(ParsedText) __);
}


/// @nodoc


class ParsedText_InviteCode extends ParsedText {
  const ParsedText_InviteCode(this.field0): super._();
  

 final  String field0;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_InviteCodeCopyWith<ParsedText_InviteCode> get copyWith => _$ParsedText_InviteCodeCopyWithImpl<ParsedText_InviteCode>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_InviteCode&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ParsedText.inviteCode(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ParsedText_InviteCodeCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_InviteCodeCopyWith(ParsedText_InviteCode value, $Res Function(ParsedText_InviteCode) _then) = _$ParsedText_InviteCodeCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$ParsedText_InviteCodeCopyWithImpl<$Res>
    implements $ParsedText_InviteCodeCopyWith<$Res> {
  _$ParsedText_InviteCodeCopyWithImpl(this._self, this._then);

  final ParsedText_InviteCode _self;
  final $Res Function(ParsedText_InviteCode) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ParsedText_InviteCode(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class ParsedText_InviteCodeWithEcash extends ParsedText {
  const ParsedText_InviteCodeWithEcash(this.field0, this.field1): super._();
  

 final  String field0;
 final  String field1;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_InviteCodeWithEcashCopyWith<ParsedText_InviteCodeWithEcash> get copyWith => _$ParsedText_InviteCodeWithEcashCopyWithImpl<ParsedText_InviteCodeWithEcash>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_InviteCodeWithEcash&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'ParsedText.inviteCodeWithEcash(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $ParsedText_InviteCodeWithEcashCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_InviteCodeWithEcashCopyWith(ParsedText_InviteCodeWithEcash value, $Res Function(ParsedText_InviteCodeWithEcash) _then) = _$ParsedText_InviteCodeWithEcashCopyWithImpl;
@useResult
$Res call({
 String field0, String field1
});




}
/// @nodoc
class _$ParsedText_InviteCodeWithEcashCopyWithImpl<$Res>
    implements $ParsedText_InviteCodeWithEcashCopyWith<$Res> {
  _$ParsedText_InviteCodeWithEcashCopyWithImpl(this._self, this._then);

  final ParsedText_InviteCodeWithEcash _self;
  final $Res Function(ParsedText_InviteCodeWithEcash) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(ParsedText_InviteCodeWithEcash(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class ParsedText_LightningInvoice extends ParsedText {
  const ParsedText_LightningInvoice(this.field0): super._();
  

 final  String field0;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_LightningInvoiceCopyWith<ParsedText_LightningInvoice> get copyWith => _$ParsedText_LightningInvoiceCopyWithImpl<ParsedText_LightningInvoice>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_LightningInvoice&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ParsedText.lightningInvoice(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ParsedText_LightningInvoiceCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_LightningInvoiceCopyWith(ParsedText_LightningInvoice value, $Res Function(ParsedText_LightningInvoice) _then) = _$ParsedText_LightningInvoiceCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$ParsedText_LightningInvoiceCopyWithImpl<$Res>
    implements $ParsedText_LightningInvoiceCopyWith<$Res> {
  _$ParsedText_LightningInvoiceCopyWithImpl(this._self, this._then);

  final ParsedText_LightningInvoice _self;
  final $Res Function(ParsedText_LightningInvoice) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ParsedText_LightningInvoice(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class ParsedText_BitcoinAddress extends ParsedText {
  const ParsedText_BitcoinAddress(this.field0, [this.field1]): super._();
  

 final  String field0;
 final  BigInt? field1;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_BitcoinAddressCopyWith<ParsedText_BitcoinAddress> get copyWith => _$ParsedText_BitcoinAddressCopyWithImpl<ParsedText_BitcoinAddress>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_BitcoinAddress&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'ParsedText.bitcoinAddress(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $ParsedText_BitcoinAddressCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_BitcoinAddressCopyWith(ParsedText_BitcoinAddress value, $Res Function(ParsedText_BitcoinAddress) _then) = _$ParsedText_BitcoinAddressCopyWithImpl;
@useResult
$Res call({
 String field0, BigInt? field1
});




}
/// @nodoc
class _$ParsedText_BitcoinAddressCopyWithImpl<$Res>
    implements $ParsedText_BitcoinAddressCopyWith<$Res> {
  _$ParsedText_BitcoinAddressCopyWithImpl(this._self, this._then);

  final ParsedText_BitcoinAddress _self;
  final $Res Function(ParsedText_BitcoinAddress) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = freezed,}) {
  return _then(ParsedText_BitcoinAddress(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,freezed == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as BigInt?,
  ));
}


}

/// @nodoc


class ParsedText_Ecash extends ParsedText {
  const ParsedText_Ecash(this.field0): super._();
  

 final  BigInt field0;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_EcashCopyWith<ParsedText_Ecash> get copyWith => _$ParsedText_EcashCopyWithImpl<ParsedText_Ecash>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_Ecash&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ParsedText.ecash(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ParsedText_EcashCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_EcashCopyWith(ParsedText_Ecash value, $Res Function(ParsedText_Ecash) _then) = _$ParsedText_EcashCopyWithImpl;
@useResult
$Res call({
 BigInt field0
});




}
/// @nodoc
class _$ParsedText_EcashCopyWithImpl<$Res>
    implements $ParsedText_EcashCopyWith<$Res> {
  _$ParsedText_EcashCopyWithImpl(this._self, this._then);

  final ParsedText_Ecash _self;
  final $Res Function(ParsedText_Ecash) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ParsedText_Ecash(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class ParsedText_LightningAddressOrLnurl extends ParsedText {
  const ParsedText_LightningAddressOrLnurl(this.field0): super._();
  

 final  String field0;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParsedText_LightningAddressOrLnurlCopyWith<ParsedText_LightningAddressOrLnurl> get copyWith => _$ParsedText_LightningAddressOrLnurlCopyWithImpl<ParsedText_LightningAddressOrLnurl>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_LightningAddressOrLnurl&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'ParsedText.lightningAddressOrLnurl(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $ParsedText_LightningAddressOrLnurlCopyWith<$Res> implements $ParsedTextCopyWith<$Res> {
  factory $ParsedText_LightningAddressOrLnurlCopyWith(ParsedText_LightningAddressOrLnurl value, $Res Function(ParsedText_LightningAddressOrLnurl) _then) = _$ParsedText_LightningAddressOrLnurlCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$ParsedText_LightningAddressOrLnurlCopyWithImpl<$Res>
    implements $ParsedText_LightningAddressOrLnurlCopyWith<$Res> {
  _$ParsedText_LightningAddressOrLnurlCopyWithImpl(this._self, this._then);

  final ParsedText_LightningAddressOrLnurl _self;
  final $Res Function(ParsedText_LightningAddressOrLnurl) _then;

/// Create a copy of ParsedText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(ParsedText_LightningAddressOrLnurl(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class ParsedText_EcashNoFederation extends ParsedText {
  const ParsedText_EcashNoFederation(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParsedText_EcashNoFederation);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'ParsedText.ecashNoFederation()';
}


}




// dart format on
