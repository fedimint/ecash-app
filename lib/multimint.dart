// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'db.dart';
import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'multimint.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `await_receive_lnv1`, `await_receive_lnv2`, `await_send_lnv1`, `await_send_lnv2`, `backup`, `build_client`, `cache_btc_price`, `cache_federation_meta`, `compute_receive_amount`, `compute_send_amount`, `finish_active_subscriptions`, `from_peg_out_fees`, `get_client_database`, `get_ecash_amount_from_meta`, `get_lnv1_amount_from_meta`, `get_lnv1_receive_tx`, `get_lnv1_send_tx`, `get_lnv2_amount_from_meta`, `get_or_build_temp_client`, `get_recurringd_federations`, `get_url`, `init_recovery_progress_cache`, `invoice_routes_back_to_federation`, `lnv1_select_gateway`, `lnv1_update_gateway_cache`, `lnv2_select_gateway`, `load_clients`, `monitor_all_unused_pegin_addresses`, `pay_lnv1`, `pay_lnv2`, `receive_amount_after_fees`, `receive_lnv1`, `receive_lnv2`, `remove_existing_ln_address`, `remove_recovery_progress_cache`, `spawn_await_ecash_reissue`, `spawn_await_ecash_send`, `spawn_await_receive`, `spawn_await_recurringd_receive`, `spawn_await_send`, `spawn_cache_task`, `spawn_pegin_address_watcher`, `spawn_recovery_progress`, `spawn_recurring_invoice_listener`, `spend_until_exact_amount`, `update_recovery_progress_cache`, `wait_for_recovery`, `watch_pegin_address`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ClientType`, `LNAddressRegisterRequest`, `LNAddressRemoveRequest`, `OnChainWithdrawalMeta`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `consensus_decode_partial_from_finite_reader`, `consensus_decode_partial_from_finite_reader`, `consensus_decode_partial_from_finite_reader`, `consensus_encode`, `consensus_encode`, `consensus_encode`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Amount>>
abstract class Amount implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>
abstract class Bolt11Invoice implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationMeta>>
abstract class FederationMeta implements RustOpaqueInterface {
  List<Guardian> get guardians;

  BigInt get lastUpdated;

  String? get lnaddressApi;

  String? get picture;

  String? get recurringdApi;

  FederationSelector get selector;

  String? get welcome;

  set guardians(List<Guardian> guardians);

  set lastUpdated(BigInt lastUpdated);

  set lnaddressApi(String? lnaddressApi);

  set picture(String? picture);

  set recurringdApi(String? recurringdApi);

  set selector(FederationSelector selector);

  set welcome(String? welcome);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationSelector>>
abstract class FederationSelector implements RustOpaqueInterface {
  FederationId get federationId;

  String get federationName;

  String? get network;

  set federationId(FederationId federationId);

  set federationName(String federationName);

  set network(String? network);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FinalReceiveOperationState>>
abstract class FinalReceiveOperationState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Multimint>>
abstract class Multimint implements RustOpaqueInterface {
  Future<void> ackSeedPhrase();

  Future<String> allocateDepositAddress({required FederationId federationId});

  Future<(ReissueExternalNotesState, BigInt?)> awaitEcashReissue({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<SpendOobState> awaitEcashSend({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<(FinalReceiveOperationState, BigInt)> awaitReceive({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<LightningSendOutcome> awaitSend({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<String> awaitWithdraw({
    required FederationId federationId,
    required OperationId operationId,
  });

  Future<BigInt> balance({required FederationId federationId});

  Future<WithdrawFeesResponse> calculateWithdrawFees({
    required FederationId federationId,
    required String address,
    required BigInt amountSats,
  });

  Future<bool> checkEcashSpent({
    required FederationId federationId,
    required String ecash,
  });

  Future<LNAddressStatus> checkLnAddressAvailability({
    required String username,
    required String domain,
    required String lnAddressApi,
    required String recurringdApi,
    required FederationId federationId,
  });

  Future<bool> containsClient({required FederationId federationId});

  Future<List<(FederationSelector, bool)>> federations();

  Future<List<(String, BigInt, BigInt?)>> getAddresses({
    required FederationId federationId,
  });

  Future<List<String>> getAllInviteCodes();

  Future<BigInt?> getBtcPrice();

  Future<FederationMeta> getCachedFederationMeta({
    String? invite,
    FederationId? federationId,
  });

  Future<DisplaySetting> getDisplaySetting();

  Future<String> getInviteCode({
    required FederationId federationId,
    required int peer,
  });

  /// Retreives currently configured Lightning Address
  Future<LightningAddressConfig?> getLnAddressConfig({
    required FederationId federationId,
  });

  Future<BigInt> getMaxWithdrawableAmount({
    required FederationId federationId,
    required String address,
  });

  Future<List<String>> getMnemonic();

  Future<List<(BigInt, BigInt)>> getNoteSummary({
    required FederationId federationId,
  });

  Future<RecoveryProgress> getRecoveryProgress({
    required FederationId federationId,
    required int moduleId,
  });

  Future<bool> hasSeedPhraseAck();

  Future<FederationSelector> joinFederation({
    required String invite,
    required bool recover,
  });

  Future<void> leaveFederation({required FederationId federationId});

  Future<List<FedimintGateway>> listGateways({
    required FederationId federationId,
  });

  Future<void> monitorDepositAddress({
    required FederationId federationId,
    required String address,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<Multimint> newInstance({
    required Database db,
    required MultimintCreation creationType,
  }) => RustLib.instance.api.crateMultimintMultimintNew(
    db: db,
    creationType: creationType,
  );

  Future<BigInt> parseEcash({
    required FederationId federationId,
    required OobNotes notes,
  });

  Future<(Bolt11Invoice, OperationId)> receive({
    required FederationId federationId,
    required BigInt amountMsatsWithFees,
    required BigInt amountMsatsWithoutFees,
    required SafeUrl gateway,
    required bool isLnv2,
  });

  Future<void> recheckAddress({
    required FederationId federationId,
    required BigInt tweakIdx,
  });

  /// Register LNURL/LN Address
  Future<void> registerLnAddress({
    required FederationId federationId,
    required String recurringdApi,
    required String lnAddressApi,
    required String username,
    required String domain,
  });

  Future<OperationId> reissueEcash({
    required FederationId federationId,
    required String ecash,
  });

  Future<void> rejoinFromBackupInvites({
    required List<String> backupInviteCodes,
  });

  Future<(String, BigInt, bool)> selectReceiveGateway({
    required FederationId federationId,
    required Amount amount,
  });

  Future<(String, BigInt, bool)> selectSendGateway({
    required FederationId federationId,
    required Amount amount,
    required Bolt11Invoice bolt11,
  });

  Future<OperationId> send({
    required FederationId federationId,
    required String invoice,
    required SafeUrl gateway,
    required bool isLnv2,
    required BigInt amountWithFees,
    String? lnAddress,
  });

  Future<(OperationId, String, BigInt)> sendEcash({
    required FederationId federationId,
    required BigInt amountMsats,
  });

  Future<void> setDisplaySetting({required DisplaySetting displaySetting});

  Future<List<Transaction>> transactions({
    required FederationId federationId,
    BigInt? timestamp,
    Uint8List? operationId,
    required List<String> modules,
  });

  Future<List<Utxo>> walletSummary({
    String? invite,
    FederationId? federationId,
  });

  Future<OperationId> withdrawToAddress({
    required FederationId federationId,
    required String address,
    required BigInt amountSats,
    required PegOutFees pegOutFees,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OOBNotes>>
abstract class OobNotes implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OperationId>>
abstract class OperationId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RecoveryProgress>>
abstract class RecoveryProgress implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReissueExternalNotesState>>
abstract class ReissueExternalNotesState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpendOOBState>>
abstract class SpendOobState implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WithdrawFeesResponse>>
abstract class WithdrawFeesResponse implements RustOpaqueInterface {
  BigInt get feeAmount;

  double get feeRateSatsPerVb;

  PegOutFees get pegOutFees;

  int get txSizeVbytes;

  set feeAmount(BigInt feeAmount);

  set feeRateSatsPerVb(double feeRateSatsPerVb);

  set pegOutFees(PegOutFees pegOutFees);

  set txSizeVbytes(int txSizeVbytes);
}

class AwaitingConfsEvent {
  final BigInt amount;
  final String outpoint;
  final BigInt blockHeight;
  final BigInt needed;

  const AwaitingConfsEvent({
    required this.amount,
    required this.outpoint,
    required this.blockHeight,
    required this.needed,
  });

  @override
  int get hashCode =>
      amount.hashCode ^
      outpoint.hashCode ^
      blockHeight.hashCode ^
      needed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AwaitingConfsEvent &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          outpoint == other.outpoint &&
          blockHeight == other.blockHeight &&
          needed == other.needed;
}

class ClaimedEvent {
  final BigInt amount;
  final String outpoint;

  const ClaimedEvent({required this.amount, required this.outpoint});

  @override
  int get hashCode => amount.hashCode ^ outpoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimedEvent &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          outpoint == other.outpoint;
}

class ConfirmedEvent {
  final BigInt amount;
  final String outpoint;

  const ConfirmedEvent({required this.amount, required this.outpoint});

  @override
  int get hashCode => amount.hashCode ^ outpoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConfirmedEvent &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          outpoint == other.outpoint;
}

@freezed
sealed class DepositEventKind with _$DepositEventKind {
  const DepositEventKind._();

  const factory DepositEventKind.mempool(MempoolEvent field0) =
      DepositEventKind_Mempool;
  const factory DepositEventKind.awaitingConfs(AwaitingConfsEvent field0) =
      DepositEventKind_AwaitingConfs;
  const factory DepositEventKind.confirmed(ConfirmedEvent field0) =
      DepositEventKind_Confirmed;
  const factory DepositEventKind.claimed(ClaimedEvent field0) =
      DepositEventKind_Claimed;
}

class FedimintGateway {
  final String endpoint;
  final BigInt baseRoutingFee;
  final BigInt ppmRoutingFee;
  final BigInt baseTransactionFee;
  final BigInt ppmTransactionFee;
  final String? lightningAlias;
  final String? lightningNode;

  const FedimintGateway({
    required this.endpoint,
    required this.baseRoutingFee,
    required this.ppmRoutingFee,
    required this.baseTransactionFee,
    required this.ppmTransactionFee,
    this.lightningAlias,
    this.lightningNode,
  });

  @override
  int get hashCode =>
      endpoint.hashCode ^
      baseRoutingFee.hashCode ^
      ppmRoutingFee.hashCode ^
      baseTransactionFee.hashCode ^
      ppmTransactionFee.hashCode ^
      lightningAlias.hashCode ^
      lightningNode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FedimintGateway &&
          runtimeType == other.runtimeType &&
          endpoint == other.endpoint &&
          baseRoutingFee == other.baseRoutingFee &&
          ppmRoutingFee == other.ppmRoutingFee &&
          baseTransactionFee == other.baseTransactionFee &&
          ppmTransactionFee == other.ppmTransactionFee &&
          lightningAlias == other.lightningAlias &&
          lightningNode == other.lightningNode;
}

class Guardian {
  final String name;
  final String? version;

  const Guardian({required this.name, this.version});

  @override
  int get hashCode => name.hashCode ^ version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Guardian &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          version == other.version;
}

class InvoicePaidEvent {
  final BigInt amountMsats;

  const InvoicePaidEvent({required this.amountMsats});

  @override
  int get hashCode => amountMsats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InvoicePaidEvent &&
          runtimeType == other.runtimeType &&
          amountMsats == other.amountMsats;
}

@freezed
sealed class LightningEventKind with _$LightningEventKind {
  const LightningEventKind._();

  const factory LightningEventKind.invoicePaid(InvoicePaidEvent field0) =
      LightningEventKind_InvoicePaid;
  const factory LightningEventKind.paymentSent() =
      LightningEventKind_PaymentSent;
}

@freezed
sealed class LightningSendOutcome with _$LightningSendOutcome {
  const LightningSendOutcome._();

  const factory LightningSendOutcome.success(String field0) =
      LightningSendOutcome_Success;
  const factory LightningSendOutcome.failure() = LightningSendOutcome_Failure;
}

@freezed
sealed class LNAddressStatus with _$LNAddressStatus {
  const LNAddressStatus._();

  const factory LNAddressStatus.registered({required String lnurl}) =
      LNAddressStatus_Registered;
  const factory LNAddressStatus.available() = LNAddressStatus_Available;
  const factory LNAddressStatus.currentConfig() = LNAddressStatus_CurrentConfig;
  const factory LNAddressStatus.unsupportedFederation() =
      LNAddressStatus_UnsupportedFederation;
  const factory LNAddressStatus.invalid() = LNAddressStatus_Invalid;
}

enum LogLevel { trace, debug, info, warn, error }

class MempoolEvent {
  final BigInt amount;
  final String outpoint;

  const MempoolEvent({required this.amount, required this.outpoint});

  @override
  int get hashCode => amount.hashCode ^ outpoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MempoolEvent &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          outpoint == other.outpoint;
}

@freezed
sealed class MultimintCreation with _$MultimintCreation {
  const MultimintCreation._();

  const factory MultimintCreation.new_() = MultimintCreation_New;
  const factory MultimintCreation.loadExisting() =
      MultimintCreation_LoadExisting;
  const factory MultimintCreation.newFromMnemonic({
    required List<String> words,
  }) = MultimintCreation_NewFromMnemonic;
}

@freezed
sealed class MultimintEvent with _$MultimintEvent {
  const MultimintEvent._();

  const factory MultimintEvent.deposit(
    (FederationId, DepositEventKind) field0,
  ) = MultimintEvent_Deposit;
  const factory MultimintEvent.lightning(
    (FederationId, LightningEventKind) field0,
  ) = MultimintEvent_Lightning;
  const factory MultimintEvent.log(LogLevel field0, String field1) =
      MultimintEvent_Log;
  const factory MultimintEvent.recoveryDone(String field0) =
      MultimintEvent_RecoveryDone;
  const factory MultimintEvent.recoveryProgress(
    String field0,
    int field1,
    int field2,
    int field3,
  ) = MultimintEvent_RecoveryProgress;
  const factory MultimintEvent.ecash((FederationId, BigInt) field0) =
      MultimintEvent_Ecash;
  const factory MultimintEvent.nostrRecovery(
    String field0,
    int field1, [
    FederationSelector? field2,
  ]) = MultimintEvent_NostrRecovery;
}

class PaymentPreview {
  final BigInt amountMsats;
  final String paymentHash;
  final String network;
  final String invoice;
  final String gateway;
  final BigInt amountWithFees;
  final bool isLnv2;

  const PaymentPreview({
    required this.amountMsats,
    required this.paymentHash,
    required this.network,
    required this.invoice,
    required this.gateway,
    required this.amountWithFees,
    required this.isLnv2,
  });

  @override
  int get hashCode =>
      amountMsats.hashCode ^
      paymentHash.hashCode ^
      network.hashCode ^
      invoice.hashCode ^
      gateway.hashCode ^
      amountWithFees.hashCode ^
      isLnv2.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentPreview &&
          runtimeType == other.runtimeType &&
          amountMsats == other.amountMsats &&
          paymentHash == other.paymentHash &&
          network == other.network &&
          invoice == other.invoice &&
          gateway == other.gateway &&
          amountWithFees == other.amountWithFees &&
          isLnv2 == other.isLnv2;
}

class Transaction {
  final TransactionKind kind;
  final BigInt amount;
  final BigInt timestamp;
  final Uint8List operationId;

  const Transaction({
    required this.kind,
    required this.amount,
    required this.timestamp,
    required this.operationId,
  });

  @override
  int get hashCode =>
      kind.hashCode ^
      amount.hashCode ^
      timestamp.hashCode ^
      operationId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Transaction &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          amount == other.amount &&
          timestamp == other.timestamp &&
          operationId == other.operationId;
}

@freezed
sealed class TransactionKind with _$TransactionKind {
  const TransactionKind._();

  const factory TransactionKind.lightningReceive({
    required BigInt fees,
    required String gateway,
    required String payeePubkey,
    required String paymentHash,
  }) = TransactionKind_LightningReceive;
  const factory TransactionKind.lightningSend({
    required BigInt fees,
    required String gateway,
    required String paymentHash,
    required String preimage,
    String? lnAddress,
  }) = TransactionKind_LightningSend;
  const factory TransactionKind.lightningRecurring() =
      TransactionKind_LightningRecurring;
  const factory TransactionKind.onchainReceive({
    required String address,
    required String txid,
  }) = TransactionKind_OnchainReceive;
  const factory TransactionKind.onchainSend({
    required String address,
    required String txid,
    double? feeRateSatsPerVb,
    int? txSizeVb,
    BigInt? feeSats,
    BigInt? totalSats,
  }) = TransactionKind_OnchainSend;
  const factory TransactionKind.ecashReceive({
    required String oobNotes,
    required BigInt fees,
  }) = TransactionKind_EcashReceive;
  const factory TransactionKind.ecashSend({
    required String oobNotes,
    required BigInt fees,
  }) = TransactionKind_EcashSend;
}

class Utxo {
  final String txid;
  final int index;
  final BigInt amount;

  const Utxo({required this.txid, required this.index, required this.amount});

  @override
  int get hashCode => txid.hashCode ^ index.hashCode ^ amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Utxo &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          index == other.index &&
          amount == other.amount;
}
