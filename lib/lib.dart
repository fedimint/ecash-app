// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'db.dart';
import 'event_bus.dart';
import 'frb_generated.dart';
import 'multimint.dart';
import 'nostr.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'lib.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `create_event_bus`, `create_nostr_client`, `error_to_flutter`, `get_database`, `get_multimint`, `get_nostr_client`, `handle_parsed_payment_instructions`, `info_to_flutter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`

Future<EventBusMultimintEvent> getEventBus() =>
    RustLib.instance.api.crateGetEventBus();

Future<void> createNewMultimint({required String path}) =>
    RustLib.instance.api.crateCreateNewMultimint(path: path);

Future<void> loadMultimint({required String path}) =>
    RustLib.instance.api.crateLoadMultimint(path: path);

Future<void> createMultimintFromWords({
  required String path,
  required List<String> words,
}) => RustLib.instance.api.crateCreateMultimintFromWords(
  path: path,
  words: words,
);

Future<bool> walletExists({required String path}) =>
    RustLib.instance.api.crateWalletExists(path: path);

Future<List<String>> getMnemonic() => RustLib.instance.api.crateGetMnemonic();

Future<FederationSelector> joinFederation({
  required String inviteCode,
  required bool recover,
}) => RustLib.instance.api.crateJoinFederation(
  inviteCode: inviteCode,
  recover: recover,
);

Future<void> backupInviteCodes() =>
    RustLib.instance.api.crateBackupInviteCodes();

Future<void> rejoinFromBackupInvites() =>
    RustLib.instance.api.crateRejoinFromBackupInvites();

Future<List<(FederationSelector, bool)>> federations() =>
    RustLib.instance.api.crateFederations();

Future<BigInt> balance({required FederationId federationId}) =>
    RustLib.instance.api.crateBalance(federationId: federationId);

Future<(String, OperationId, String, String, BigInt)> receive({
  required FederationId federationId,
  required BigInt amountMsatsWithFees,
  required BigInt amountMsatsWithoutFees,
  required String gateway,
  required bool isLnv2,
}) => RustLib.instance.api.crateReceive(
  federationId: federationId,
  amountMsatsWithFees: amountMsatsWithFees,
  amountMsatsWithoutFees: amountMsatsWithoutFees,
  gateway: gateway,
  isLnv2: isLnv2,
);

Future<(String, BigInt, bool)> selectReceiveGateway({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSelectReceiveGateway(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<OperationId> sendLnaddress({
  required FederationId federationId,
  required BigInt amountMsats,
  required String address,
}) => RustLib.instance.api.crateSendLnaddress(
  federationId: federationId,
  amountMsats: amountMsats,
  address: address,
);

Future<OperationId> send({
  required FederationId federationId,
  required String invoice,
  required String gateway,
  required bool isLnv2,
  required BigInt amountWithFees,
}) => RustLib.instance.api.crateSend(
  federationId: federationId,
  invoice: invoice,
  gateway: gateway,
  isLnv2: isLnv2,
  amountWithFees: amountWithFees,
);

Future<LightningSendOutcome> awaitSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitSend(
  federationId: federationId,
  operationId: operationId,
);

Future<(FinalReceiveOperationState, BigInt)> awaitReceive({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitReceive(
  federationId: federationId,
  operationId: operationId,
);

Future<List<PublicFederation>> listFederationsFromNostr({
  required bool forceUpdate,
}) => RustLib.instance.api.crateListFederationsFromNostr(
  forceUpdate: forceUpdate,
);

Future<PaymentPreview> paymentPreview({
  required FederationId federationId,
  required String bolt11,
}) => RustLib.instance.api.cratePaymentPreview(
  federationId: federationId,
  bolt11: bolt11,
);

Future<FederationMeta> getFederationMeta({
  String? inviteCode,
  FederationId? federationId,
}) => RustLib.instance.api.crateGetFederationMeta(
  inviteCode: inviteCode,
  federationId: federationId,
);

Future<List<Transaction>> transactions({
  required FederationId federationId,
  BigInt? timestamp,
  Uint8List? operationId,
  required List<String> modules,
}) => RustLib.instance.api.crateTransactions(
  federationId: federationId,
  timestamp: timestamp,
  operationId: operationId,
  modules: modules,
);

Future<(OperationId, String, BigInt)> sendEcash({
  required FederationId federationId,
  required BigInt amountMsats,
}) => RustLib.instance.api.crateSendEcash(
  federationId: federationId,
  amountMsats: amountMsats,
);

Future<SpendOobState> awaitEcashSend({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashSend(
  federationId: federationId,
  operationId: operationId,
);

Future<BigInt> parseEcash({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateParseEcash(
  federationId: federationId,
  ecash: ecash,
);

Future<OperationId> reissueEcash({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateReissueEcash(
  federationId: federationId,
  ecash: ecash,
);

Future<(ReissueExternalNotesState, BigInt?)> awaitEcashReissue({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitEcashReissue(
  federationId: federationId,
  operationId: operationId,
);

Future<bool> hasSeedPhraseAck() => RustLib.instance.api.crateHasSeedPhraseAck();

Future<void> ackSeedPhrase() => RustLib.instance.api.crateAckSeedPhrase();

Future<List<String>> wordList() => RustLib.instance.api.crateWordList();

Stream<DepositEventKind> subscribeDeposits({
  required FederationId federationId,
}) => RustLib.instance.api.crateSubscribeDeposits(federationId: federationId);

Future<void> monitorDepositAddress({
  required FederationId federationId,
  required String address,
}) => RustLib.instance.api.crateMonitorDepositAddress(
  federationId: federationId,
  address: address,
);

Future<String> allocateDepositAddress({required FederationId federationId}) =>
    RustLib.instance.api.crateAllocateDepositAddress(
      federationId: federationId,
    );

Future<List<(FederationSelector, NWCConnectionInfo)>> getNwcConnectionInfo() =>
    RustLib.instance.api.crateGetNwcConnectionInfo();

Future<NWCConnectionInfo> setNwcConnectionInfo({
  required FederationId federationId,
  required String relay,
}) => RustLib.instance.api.crateSetNwcConnectionInfo(
  federationId: federationId,
  relay: relay,
);

Future<List<(String, bool)>> getRelays() =>
    RustLib.instance.api.crateGetRelays();

Future<List<Utxo>> walletSummary({
  String? invite,
  FederationId? federationId,
}) => RustLib.instance.api.crateWalletSummary(
  invite: invite,
  federationId: federationId,
);

Stream<MultimintEvent> subscribeMultimintEvents() =>
    RustLib.instance.api.crateSubscribeMultimintEvents();

Future<String> federationIdToString({required FederationId federationId}) =>
    RustLib.instance.api.crateFederationIdToString(federationId: federationId);

Future<BigInt?> getBtcPrice() => RustLib.instance.api.crateGetBtcPrice();

Future<WithdrawFeesResponse> calculateWithdrawFees({
  required FederationId federationId,
  required String address,
  required BigInt amountSats,
}) => RustLib.instance.api.crateCalculateWithdrawFees(
  federationId: federationId,
  address: address,
  amountSats: amountSats,
);

Future<OperationId> withdrawToAddress({
  required FederationId federationId,
  required String address,
  required BigInt amountSats,
  required PegOutFees pegOutFees,
}) => RustLib.instance.api.crateWithdrawToAddress(
  federationId: federationId,
  address: address,
  amountSats: amountSats,
  pegOutFees: pegOutFees,
);

Future<String> awaitWithdraw({
  required FederationId federationId,
  required OperationId operationId,
}) => RustLib.instance.api.crateAwaitWithdraw(
  federationId: federationId,
  operationId: operationId,
);

Future<BigInt> getMaxWithdrawableAmount({
  required FederationId federationId,
  required String address,
}) => RustLib.instance.api.crateGetMaxWithdrawableAmount(
  federationId: federationId,
  address: address,
);

Future<(int, int)> getModuleRecoveryProgress({
  required FederationId federationId,
  required int moduleId,
}) => RustLib.instance.api.crateGetModuleRecoveryProgress(
  federationId: federationId,
  moduleId: moduleId,
);

Stream<(int, int)> subscribeRecoveryProgress({
  required FederationId federationId,
  required int moduleId,
}) => RustLib.instance.api.crateSubscribeRecoveryProgress(
  federationId: federationId,
  moduleId: moduleId,
);

Future<(ParsedText, FederationSelector)> parseScannedTextForFederation({
  required String text,
  required FederationSelector federation,
}) => RustLib.instance.api.crateParseScannedTextForFederation(
  text: text,
  federation: federation,
);

Future<(ParsedText, FederationSelector?)> parsedScannedText({
  required String text,
}) => RustLib.instance.api.crateParsedScannedText(text: text);

Future<void> insertRelay({required String relayUri}) =>
    RustLib.instance.api.crateInsertRelay(relayUri: relayUri);

Future<void> removeRelay({required String relayUri}) =>
    RustLib.instance.api.crateRemoveRelay(relayUri: relayUri);

Future<List<(String, BigInt, BigInt?)>> getAddresses({
  required FederationId federationId,
}) => RustLib.instance.api.crateGetAddresses(federationId: federationId);

Future<void> recheckAddress({
  required FederationId federationId,
  required BigInt tweakIdx,
}) => RustLib.instance.api.crateRecheckAddress(
  federationId: federationId,
  tweakIdx: tweakIdx,
);

Future<List<(BigInt, BigInt)>> getNoteSummary({
  required FederationId federationId,
}) => RustLib.instance.api.crateGetNoteSummary(federationId: federationId);

Future<List<FedimintGateway>> listGateways({
  required FederationId federationId,
}) => RustLib.instance.api.crateListGateways(federationId: federationId);

Future<bool> checkEcashSpent({
  required FederationId federationId,
  required String ecash,
}) => RustLib.instance.api.crateCheckEcashSpent(
  federationId: federationId,
  ecash: ecash,
);

Future<List<String>> listLnAddressDomains({required String lnAddressApi}) =>
    RustLib.instance.api.crateListLnAddressDomains(lnAddressApi: lnAddressApi);

Future<LightningAddressConfig?> getLnAddressConfig({
  required FederationId federationId,
}) => RustLib.instance.api.crateGetLnAddressConfig(federationId: federationId);

Future<LNAddressStatus> checkLnAddressAvailability({
  required String username,
  required String domain,
  required String lnAddressApi,
  required String recurringdApi,
  required FederationId federationId,
}) => RustLib.instance.api.crateCheckLnAddressAvailability(
  username: username,
  domain: domain,
  lnAddressApi: lnAddressApi,
  recurringdApi: recurringdApi,
  federationId: federationId,
);

Future<void> registerLnAddress({
  required FederationId federationId,
  required String recurringdApi,
  required String lnAddressApi,
  required String username,
  required String domain,
}) => RustLib.instance.api.crateRegisterLnAddress(
  federationId: federationId,
  recurringdApi: recurringdApi,
  lnAddressApi: lnAddressApi,
  username: username,
  domain: domain,
);

Future<String> getInviteCode({
  required FederationId federationId,
  required int peer,
}) => RustLib.instance.api.crateGetInviteCode(
  federationId: federationId,
  peer: peer,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientConfig>>
abstract class ClientConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Connector>>
abstract class Connector implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Database>>
abstract class Database implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FederationId>>
abstract class FederationId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PegOutFees>>
abstract class PegOutFees implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SafeUrl>>
abstract class SafeUrl implements RustOpaqueInterface {}

@freezed
sealed class ParsedText with _$ParsedText {
  const ParsedText._();

  const factory ParsedText.inviteCode(String field0) = ParsedText_InviteCode;
  const factory ParsedText.lightningInvoice(String field0) =
      ParsedText_LightningInvoice;
  const factory ParsedText.bitcoinAddress(String field0, [BigInt? field1]) =
      ParsedText_BitcoinAddress;
  const factory ParsedText.ecash(BigInt field0) = ParsedText_Ecash;
}
