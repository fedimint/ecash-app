// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'multimint.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$DepositEventKind {

 Object get field0;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DepositEventKind&&const DeepCollectionEquality().equals(other.field0, field0));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(field0));

@override
String toString() {
  return 'DepositEventKind(field0: $field0)';
}


}

/// @nodoc
class $DepositEventKindCopyWith<$Res>  {
$DepositEventKindCopyWith(DepositEventKind _, $Res Function(DepositEventKind) __);
}


/// @nodoc


class DepositEventKind_Mempool extends DepositEventKind {
  const DepositEventKind_Mempool(this.field0): super._();
  

@override final  MempoolEvent field0;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DepositEventKind_MempoolCopyWith<DepositEventKind_Mempool> get copyWith => _$DepositEventKind_MempoolCopyWithImpl<DepositEventKind_Mempool>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DepositEventKind_Mempool&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'DepositEventKind.mempool(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $DepositEventKind_MempoolCopyWith<$Res> implements $DepositEventKindCopyWith<$Res> {
  factory $DepositEventKind_MempoolCopyWith(DepositEventKind_Mempool value, $Res Function(DepositEventKind_Mempool) _then) = _$DepositEventKind_MempoolCopyWithImpl;
@useResult
$Res call({
 MempoolEvent field0
});




}
/// @nodoc
class _$DepositEventKind_MempoolCopyWithImpl<$Res>
    implements $DepositEventKind_MempoolCopyWith<$Res> {
  _$DepositEventKind_MempoolCopyWithImpl(this._self, this._then);

  final DepositEventKind_Mempool _self;
  final $Res Function(DepositEventKind_Mempool) _then;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(DepositEventKind_Mempool(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as MempoolEvent,
  ));
}


}

/// @nodoc


class DepositEventKind_AwaitingConfs extends DepositEventKind {
  const DepositEventKind_AwaitingConfs(this.field0): super._();
  

@override final  AwaitingConfsEvent field0;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DepositEventKind_AwaitingConfsCopyWith<DepositEventKind_AwaitingConfs> get copyWith => _$DepositEventKind_AwaitingConfsCopyWithImpl<DepositEventKind_AwaitingConfs>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DepositEventKind_AwaitingConfs&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'DepositEventKind.awaitingConfs(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $DepositEventKind_AwaitingConfsCopyWith<$Res> implements $DepositEventKindCopyWith<$Res> {
  factory $DepositEventKind_AwaitingConfsCopyWith(DepositEventKind_AwaitingConfs value, $Res Function(DepositEventKind_AwaitingConfs) _then) = _$DepositEventKind_AwaitingConfsCopyWithImpl;
@useResult
$Res call({
 AwaitingConfsEvent field0
});




}
/// @nodoc
class _$DepositEventKind_AwaitingConfsCopyWithImpl<$Res>
    implements $DepositEventKind_AwaitingConfsCopyWith<$Res> {
  _$DepositEventKind_AwaitingConfsCopyWithImpl(this._self, this._then);

  final DepositEventKind_AwaitingConfs _self;
  final $Res Function(DepositEventKind_AwaitingConfs) _then;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(DepositEventKind_AwaitingConfs(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as AwaitingConfsEvent,
  ));
}


}

/// @nodoc


class DepositEventKind_Confirmed extends DepositEventKind {
  const DepositEventKind_Confirmed(this.field0): super._();
  

@override final  ConfirmedEvent field0;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DepositEventKind_ConfirmedCopyWith<DepositEventKind_Confirmed> get copyWith => _$DepositEventKind_ConfirmedCopyWithImpl<DepositEventKind_Confirmed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DepositEventKind_Confirmed&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'DepositEventKind.confirmed(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $DepositEventKind_ConfirmedCopyWith<$Res> implements $DepositEventKindCopyWith<$Res> {
  factory $DepositEventKind_ConfirmedCopyWith(DepositEventKind_Confirmed value, $Res Function(DepositEventKind_Confirmed) _then) = _$DepositEventKind_ConfirmedCopyWithImpl;
@useResult
$Res call({
 ConfirmedEvent field0
});




}
/// @nodoc
class _$DepositEventKind_ConfirmedCopyWithImpl<$Res>
    implements $DepositEventKind_ConfirmedCopyWith<$Res> {
  _$DepositEventKind_ConfirmedCopyWithImpl(this._self, this._then);

  final DepositEventKind_Confirmed _self;
  final $Res Function(DepositEventKind_Confirmed) _then;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(DepositEventKind_Confirmed(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as ConfirmedEvent,
  ));
}


}

/// @nodoc


class DepositEventKind_Claimed extends DepositEventKind {
  const DepositEventKind_Claimed(this.field0): super._();
  

@override final  ClaimedEvent field0;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DepositEventKind_ClaimedCopyWith<DepositEventKind_Claimed> get copyWith => _$DepositEventKind_ClaimedCopyWithImpl<DepositEventKind_Claimed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DepositEventKind_Claimed&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'DepositEventKind.claimed(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $DepositEventKind_ClaimedCopyWith<$Res> implements $DepositEventKindCopyWith<$Res> {
  factory $DepositEventKind_ClaimedCopyWith(DepositEventKind_Claimed value, $Res Function(DepositEventKind_Claimed) _then) = _$DepositEventKind_ClaimedCopyWithImpl;
@useResult
$Res call({
 ClaimedEvent field0
});




}
/// @nodoc
class _$DepositEventKind_ClaimedCopyWithImpl<$Res>
    implements $DepositEventKind_ClaimedCopyWith<$Res> {
  _$DepositEventKind_ClaimedCopyWithImpl(this._self, this._then);

  final DepositEventKind_Claimed _self;
  final $Res Function(DepositEventKind_Claimed) _then;

/// Create a copy of DepositEventKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(DepositEventKind_Claimed(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as ClaimedEvent,
  ));
}


}

/// @nodoc
mixin _$LightningEventKind {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningEventKind);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LightningEventKind()';
}


}

/// @nodoc
class $LightningEventKindCopyWith<$Res>  {
$LightningEventKindCopyWith(LightningEventKind _, $Res Function(LightningEventKind) __);
}


/// @nodoc


class LightningEventKind_InvoicePaid extends LightningEventKind {
  const LightningEventKind_InvoicePaid(this.field0): super._();
  

 final  InvoicePaidEvent field0;

/// Create a copy of LightningEventKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LightningEventKind_InvoicePaidCopyWith<LightningEventKind_InvoicePaid> get copyWith => _$LightningEventKind_InvoicePaidCopyWithImpl<LightningEventKind_InvoicePaid>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningEventKind_InvoicePaid&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'LightningEventKind.invoicePaid(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $LightningEventKind_InvoicePaidCopyWith<$Res> implements $LightningEventKindCopyWith<$Res> {
  factory $LightningEventKind_InvoicePaidCopyWith(LightningEventKind_InvoicePaid value, $Res Function(LightningEventKind_InvoicePaid) _then) = _$LightningEventKind_InvoicePaidCopyWithImpl;
@useResult
$Res call({
 InvoicePaidEvent field0
});




}
/// @nodoc
class _$LightningEventKind_InvoicePaidCopyWithImpl<$Res>
    implements $LightningEventKind_InvoicePaidCopyWith<$Res> {
  _$LightningEventKind_InvoicePaidCopyWithImpl(this._self, this._then);

  final LightningEventKind_InvoicePaid _self;
  final $Res Function(LightningEventKind_InvoicePaid) _then;

/// Create a copy of LightningEventKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(LightningEventKind_InvoicePaid(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as InvoicePaidEvent,
  ));
}


}

/// @nodoc


class LightningEventKind_PaymentSent extends LightningEventKind {
  const LightningEventKind_PaymentSent(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningEventKind_PaymentSent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LightningEventKind.paymentSent()';
}


}




/// @nodoc
mixin _$LightningSendOutcome {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningSendOutcome);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LightningSendOutcome()';
}


}

/// @nodoc
class $LightningSendOutcomeCopyWith<$Res>  {
$LightningSendOutcomeCopyWith(LightningSendOutcome _, $Res Function(LightningSendOutcome) __);
}


/// @nodoc


class LightningSendOutcome_Success extends LightningSendOutcome {
  const LightningSendOutcome_Success(this.field0): super._();
  

 final  String field0;

/// Create a copy of LightningSendOutcome
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LightningSendOutcome_SuccessCopyWith<LightningSendOutcome_Success> get copyWith => _$LightningSendOutcome_SuccessCopyWithImpl<LightningSendOutcome_Success>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningSendOutcome_Success&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'LightningSendOutcome.success(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $LightningSendOutcome_SuccessCopyWith<$Res> implements $LightningSendOutcomeCopyWith<$Res> {
  factory $LightningSendOutcome_SuccessCopyWith(LightningSendOutcome_Success value, $Res Function(LightningSendOutcome_Success) _then) = _$LightningSendOutcome_SuccessCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$LightningSendOutcome_SuccessCopyWithImpl<$Res>
    implements $LightningSendOutcome_SuccessCopyWith<$Res> {
  _$LightningSendOutcome_SuccessCopyWithImpl(this._self, this._then);

  final LightningSendOutcome_Success _self;
  final $Res Function(LightningSendOutcome_Success) _then;

/// Create a copy of LightningSendOutcome
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(LightningSendOutcome_Success(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LightningSendOutcome_Failure extends LightningSendOutcome {
  const LightningSendOutcome_Failure(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LightningSendOutcome_Failure);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LightningSendOutcome.failure()';
}


}




/// @nodoc
mixin _$LNAddressStatus {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LNAddressStatus()';
}


}

/// @nodoc
class $LNAddressStatusCopyWith<$Res>  {
$LNAddressStatusCopyWith(LNAddressStatus _, $Res Function(LNAddressStatus) __);
}


/// @nodoc


class LNAddressStatus_Registered extends LNAddressStatus {
  const LNAddressStatus_Registered({required this.lnurl}): super._();
  

 final  String lnurl;

/// Create a copy of LNAddressStatus
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LNAddressStatus_RegisteredCopyWith<LNAddressStatus_Registered> get copyWith => _$LNAddressStatus_RegisteredCopyWithImpl<LNAddressStatus_Registered>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus_Registered&&(identical(other.lnurl, lnurl) || other.lnurl == lnurl));
}


@override
int get hashCode => Object.hash(runtimeType,lnurl);

@override
String toString() {
  return 'LNAddressStatus.registered(lnurl: $lnurl)';
}


}

/// @nodoc
abstract mixin class $LNAddressStatus_RegisteredCopyWith<$Res> implements $LNAddressStatusCopyWith<$Res> {
  factory $LNAddressStatus_RegisteredCopyWith(LNAddressStatus_Registered value, $Res Function(LNAddressStatus_Registered) _then) = _$LNAddressStatus_RegisteredCopyWithImpl;
@useResult
$Res call({
 String lnurl
});




}
/// @nodoc
class _$LNAddressStatus_RegisteredCopyWithImpl<$Res>
    implements $LNAddressStatus_RegisteredCopyWith<$Res> {
  _$LNAddressStatus_RegisteredCopyWithImpl(this._self, this._then);

  final LNAddressStatus_Registered _self;
  final $Res Function(LNAddressStatus_Registered) _then;

/// Create a copy of LNAddressStatus
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? lnurl = null,}) {
  return _then(LNAddressStatus_Registered(
lnurl: null == lnurl ? _self.lnurl : lnurl // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LNAddressStatus_Available extends LNAddressStatus {
  const LNAddressStatus_Available(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus_Available);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LNAddressStatus.available()';
}


}




/// @nodoc


class LNAddressStatus_CurrentConfig extends LNAddressStatus {
  const LNAddressStatus_CurrentConfig(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus_CurrentConfig);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LNAddressStatus.currentConfig()';
}


}




/// @nodoc


class LNAddressStatus_UnsupportedFederation extends LNAddressStatus {
  const LNAddressStatus_UnsupportedFederation(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus_UnsupportedFederation);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LNAddressStatus.unsupportedFederation()';
}


}




/// @nodoc


class LNAddressStatus_Invalid extends LNAddressStatus {
  const LNAddressStatus_Invalid(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LNAddressStatus_Invalid);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'LNAddressStatus.invalid()';
}


}




/// @nodoc
mixin _$MultimintCreation {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintCreation);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MultimintCreation()';
}


}

/// @nodoc
class $MultimintCreationCopyWith<$Res>  {
$MultimintCreationCopyWith(MultimintCreation _, $Res Function(MultimintCreation) __);
}


/// @nodoc


class MultimintCreation_New extends MultimintCreation {
  const MultimintCreation_New(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintCreation_New);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MultimintCreation.new_()';
}


}




/// @nodoc


class MultimintCreation_LoadExisting extends MultimintCreation {
  const MultimintCreation_LoadExisting(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintCreation_LoadExisting);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'MultimintCreation.loadExisting()';
}


}




/// @nodoc


class MultimintCreation_NewFromMnemonic extends MultimintCreation {
  const MultimintCreation_NewFromMnemonic({required final  List<String> words}): _words = words,super._();
  

 final  List<String> _words;
 List<String> get words {
  if (_words is EqualUnmodifiableListView) return _words;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_words);
}


/// Create a copy of MultimintCreation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintCreation_NewFromMnemonicCopyWith<MultimintCreation_NewFromMnemonic> get copyWith => _$MultimintCreation_NewFromMnemonicCopyWithImpl<MultimintCreation_NewFromMnemonic>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintCreation_NewFromMnemonic&&const DeepCollectionEquality().equals(other._words, _words));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_words));

@override
String toString() {
  return 'MultimintCreation.newFromMnemonic(words: $words)';
}


}

/// @nodoc
abstract mixin class $MultimintCreation_NewFromMnemonicCopyWith<$Res> implements $MultimintCreationCopyWith<$Res> {
  factory $MultimintCreation_NewFromMnemonicCopyWith(MultimintCreation_NewFromMnemonic value, $Res Function(MultimintCreation_NewFromMnemonic) _then) = _$MultimintCreation_NewFromMnemonicCopyWithImpl;
@useResult
$Res call({
 List<String> words
});




}
/// @nodoc
class _$MultimintCreation_NewFromMnemonicCopyWithImpl<$Res>
    implements $MultimintCreation_NewFromMnemonicCopyWith<$Res> {
  _$MultimintCreation_NewFromMnemonicCopyWithImpl(this._self, this._then);

  final MultimintCreation_NewFromMnemonic _self;
  final $Res Function(MultimintCreation_NewFromMnemonic) _then;

/// Create a copy of MultimintCreation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? words = null,}) {
  return _then(MultimintCreation_NewFromMnemonic(
words: null == words ? _self._words : words // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}

/// @nodoc
mixin _$MultimintEvent {

 Object get field0;



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent&&const DeepCollectionEquality().equals(other.field0, field0));
}


@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(field0));

@override
String toString() {
  return 'MultimintEvent(field0: $field0)';
}


}

/// @nodoc
class $MultimintEventCopyWith<$Res>  {
$MultimintEventCopyWith(MultimintEvent _, $Res Function(MultimintEvent) __);
}


/// @nodoc


class MultimintEvent_Deposit extends MultimintEvent {
  const MultimintEvent_Deposit(this.field0): super._();
  

@override final  (FederationId, DepositEventKind) field0;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_DepositCopyWith<MultimintEvent_Deposit> get copyWith => _$MultimintEvent_DepositCopyWithImpl<MultimintEvent_Deposit>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_Deposit&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'MultimintEvent.deposit(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_DepositCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_DepositCopyWith(MultimintEvent_Deposit value, $Res Function(MultimintEvent_Deposit) _then) = _$MultimintEvent_DepositCopyWithImpl;
@useResult
$Res call({
 (FederationId, DepositEventKind) field0
});




}
/// @nodoc
class _$MultimintEvent_DepositCopyWithImpl<$Res>
    implements $MultimintEvent_DepositCopyWith<$Res> {
  _$MultimintEvent_DepositCopyWithImpl(this._self, this._then);

  final MultimintEvent_Deposit _self;
  final $Res Function(MultimintEvent_Deposit) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(MultimintEvent_Deposit(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as (FederationId, DepositEventKind),
  ));
}


}

/// @nodoc


class MultimintEvent_Lightning extends MultimintEvent {
  const MultimintEvent_Lightning(this.field0): super._();
  

@override final  (FederationId, LightningEventKind) field0;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_LightningCopyWith<MultimintEvent_Lightning> get copyWith => _$MultimintEvent_LightningCopyWithImpl<MultimintEvent_Lightning>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_Lightning&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'MultimintEvent.lightning(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_LightningCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_LightningCopyWith(MultimintEvent_Lightning value, $Res Function(MultimintEvent_Lightning) _then) = _$MultimintEvent_LightningCopyWithImpl;
@useResult
$Res call({
 (FederationId, LightningEventKind) field0
});




}
/// @nodoc
class _$MultimintEvent_LightningCopyWithImpl<$Res>
    implements $MultimintEvent_LightningCopyWith<$Res> {
  _$MultimintEvent_LightningCopyWithImpl(this._self, this._then);

  final MultimintEvent_Lightning _self;
  final $Res Function(MultimintEvent_Lightning) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(MultimintEvent_Lightning(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as (FederationId, LightningEventKind),
  ));
}


}

/// @nodoc


class MultimintEvent_Log extends MultimintEvent {
  const MultimintEvent_Log(this.field0, this.field1): super._();
  

@override final  LogLevel field0;
 final  String field1;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_LogCopyWith<MultimintEvent_Log> get copyWith => _$MultimintEvent_LogCopyWithImpl<MultimintEvent_Log>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_Log&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@override
String toString() {
  return 'MultimintEvent.log(field0: $field0, field1: $field1)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_LogCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_LogCopyWith(MultimintEvent_Log value, $Res Function(MultimintEvent_Log) _then) = _$MultimintEvent_LogCopyWithImpl;
@useResult
$Res call({
 LogLevel field0, String field1
});




}
/// @nodoc
class _$MultimintEvent_LogCopyWithImpl<$Res>
    implements $MultimintEvent_LogCopyWith<$Res> {
  _$MultimintEvent_LogCopyWithImpl(this._self, this._then);

  final MultimintEvent_Log _self;
  final $Res Function(MultimintEvent_Log) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(MultimintEvent_Log(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as LogLevel,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class MultimintEvent_RecoveryDone extends MultimintEvent {
  const MultimintEvent_RecoveryDone(this.field0): super._();
  

@override final  String field0;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_RecoveryDoneCopyWith<MultimintEvent_RecoveryDone> get copyWith => _$MultimintEvent_RecoveryDoneCopyWithImpl<MultimintEvent_RecoveryDone>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_RecoveryDone&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'MultimintEvent.recoveryDone(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_RecoveryDoneCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_RecoveryDoneCopyWith(MultimintEvent_RecoveryDone value, $Res Function(MultimintEvent_RecoveryDone) _then) = _$MultimintEvent_RecoveryDoneCopyWithImpl;
@useResult
$Res call({
 String field0
});




}
/// @nodoc
class _$MultimintEvent_RecoveryDoneCopyWithImpl<$Res>
    implements $MultimintEvent_RecoveryDoneCopyWith<$Res> {
  _$MultimintEvent_RecoveryDoneCopyWithImpl(this._self, this._then);

  final MultimintEvent_RecoveryDone _self;
  final $Res Function(MultimintEvent_RecoveryDone) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(MultimintEvent_RecoveryDone(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class MultimintEvent_RecoveryProgress extends MultimintEvent {
  const MultimintEvent_RecoveryProgress(this.field0, this.field1, this.field2, this.field3): super._();
  

@override final  String field0;
 final  int field1;
 final  int field2;
 final  int field3;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_RecoveryProgressCopyWith<MultimintEvent_RecoveryProgress> get copyWith => _$MultimintEvent_RecoveryProgressCopyWithImpl<MultimintEvent_RecoveryProgress>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_RecoveryProgress&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1)&&(identical(other.field2, field2) || other.field2 == field2)&&(identical(other.field3, field3) || other.field3 == field3));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1,field2,field3);

@override
String toString() {
  return 'MultimintEvent.recoveryProgress(field0: $field0, field1: $field1, field2: $field2, field3: $field3)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_RecoveryProgressCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_RecoveryProgressCopyWith(MultimintEvent_RecoveryProgress value, $Res Function(MultimintEvent_RecoveryProgress) _then) = _$MultimintEvent_RecoveryProgressCopyWithImpl;
@useResult
$Res call({
 String field0, int field1, int field2, int field3
});




}
/// @nodoc
class _$MultimintEvent_RecoveryProgressCopyWithImpl<$Res>
    implements $MultimintEvent_RecoveryProgressCopyWith<$Res> {
  _$MultimintEvent_RecoveryProgressCopyWithImpl(this._self, this._then);

  final MultimintEvent_RecoveryProgress _self;
  final $Res Function(MultimintEvent_RecoveryProgress) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,Object? field2 = null,Object? field3 = null,}) {
  return _then(MultimintEvent_RecoveryProgress(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as int,null == field2 ? _self.field2 : field2 // ignore: cast_nullable_to_non_nullable
as int,null == field3 ? _self.field3 : field3 // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class MultimintEvent_Ecash extends MultimintEvent {
  const MultimintEvent_Ecash(this.field0): super._();
  

@override final  (FederationId, BigInt) field0;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_EcashCopyWith<MultimintEvent_Ecash> get copyWith => _$MultimintEvent_EcashCopyWithImpl<MultimintEvent_Ecash>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_Ecash&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@override
String toString() {
  return 'MultimintEvent.ecash(field0: $field0)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_EcashCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_EcashCopyWith(MultimintEvent_Ecash value, $Res Function(MultimintEvent_Ecash) _then) = _$MultimintEvent_EcashCopyWithImpl;
@useResult
$Res call({
 (FederationId, BigInt) field0
});




}
/// @nodoc
class _$MultimintEvent_EcashCopyWithImpl<$Res>
    implements $MultimintEvent_EcashCopyWith<$Res> {
  _$MultimintEvent_EcashCopyWithImpl(this._self, this._then);

  final MultimintEvent_Ecash _self;
  final $Res Function(MultimintEvent_Ecash) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,}) {
  return _then(MultimintEvent_Ecash(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as (FederationId, BigInt),
  ));
}


}

/// @nodoc


class MultimintEvent_NostrRecovery extends MultimintEvent {
  const MultimintEvent_NostrRecovery(this.field0, this.field1, [this.field2]): super._();
  

@override final  String field0;
 final  int field1;
 final  FederationSelector? field2;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MultimintEvent_NostrRecoveryCopyWith<MultimintEvent_NostrRecovery> get copyWith => _$MultimintEvent_NostrRecoveryCopyWithImpl<MultimintEvent_NostrRecovery>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MultimintEvent_NostrRecovery&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1)&&(identical(other.field2, field2) || other.field2 == field2));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1,field2);

@override
String toString() {
  return 'MultimintEvent.nostrRecovery(field0: $field0, field1: $field1, field2: $field2)';
}


}

/// @nodoc
abstract mixin class $MultimintEvent_NostrRecoveryCopyWith<$Res> implements $MultimintEventCopyWith<$Res> {
  factory $MultimintEvent_NostrRecoveryCopyWith(MultimintEvent_NostrRecovery value, $Res Function(MultimintEvent_NostrRecovery) _then) = _$MultimintEvent_NostrRecoveryCopyWithImpl;
@useResult
$Res call({
 String field0, int field1, FederationSelector? field2
});




}
/// @nodoc
class _$MultimintEvent_NostrRecoveryCopyWithImpl<$Res>
    implements $MultimintEvent_NostrRecoveryCopyWith<$Res> {
  _$MultimintEvent_NostrRecoveryCopyWithImpl(this._self, this._then);

  final MultimintEvent_NostrRecovery _self;
  final $Res Function(MultimintEvent_NostrRecovery) _then;

/// Create a copy of MultimintEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? field0 = null,Object? field1 = null,Object? field2 = freezed,}) {
  return _then(MultimintEvent_NostrRecovery(
null == field0 ? _self.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,null == field1 ? _self.field1 : field1 // ignore: cast_nullable_to_non_nullable
as int,freezed == field2 ? _self.field2 : field2 // ignore: cast_nullable_to_non_nullable
as FederationSelector?,
  ));
}


}

/// @nodoc
mixin _$TransactionKind {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionKind()';
}


}

/// @nodoc
class $TransactionKindCopyWith<$Res>  {
$TransactionKindCopyWith(TransactionKind _, $Res Function(TransactionKind) __);
}


/// @nodoc


class TransactionKind_LightningReceive extends TransactionKind {
  const TransactionKind_LightningReceive({required this.fees, required this.gateway, required this.payeePubkey, required this.paymentHash}): super._();
  

 final  BigInt fees;
 final  String gateway;
 final  String payeePubkey;
 final  String paymentHash;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_LightningReceiveCopyWith<TransactionKind_LightningReceive> get copyWith => _$TransactionKind_LightningReceiveCopyWithImpl<TransactionKind_LightningReceive>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_LightningReceive&&(identical(other.fees, fees) || other.fees == fees)&&(identical(other.gateway, gateway) || other.gateway == gateway)&&(identical(other.payeePubkey, payeePubkey) || other.payeePubkey == payeePubkey)&&(identical(other.paymentHash, paymentHash) || other.paymentHash == paymentHash));
}


@override
int get hashCode => Object.hash(runtimeType,fees,gateway,payeePubkey,paymentHash);

@override
String toString() {
  return 'TransactionKind.lightningReceive(fees: $fees, gateway: $gateway, payeePubkey: $payeePubkey, paymentHash: $paymentHash)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_LightningReceiveCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_LightningReceiveCopyWith(TransactionKind_LightningReceive value, $Res Function(TransactionKind_LightningReceive) _then) = _$TransactionKind_LightningReceiveCopyWithImpl;
@useResult
$Res call({
 BigInt fees, String gateway, String payeePubkey, String paymentHash
});




}
/// @nodoc
class _$TransactionKind_LightningReceiveCopyWithImpl<$Res>
    implements $TransactionKind_LightningReceiveCopyWith<$Res> {
  _$TransactionKind_LightningReceiveCopyWithImpl(this._self, this._then);

  final TransactionKind_LightningReceive _self;
  final $Res Function(TransactionKind_LightningReceive) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? fees = null,Object? gateway = null,Object? payeePubkey = null,Object? paymentHash = null,}) {
  return _then(TransactionKind_LightningReceive(
fees: null == fees ? _self.fees : fees // ignore: cast_nullable_to_non_nullable
as BigInt,gateway: null == gateway ? _self.gateway : gateway // ignore: cast_nullable_to_non_nullable
as String,payeePubkey: null == payeePubkey ? _self.payeePubkey : payeePubkey // ignore: cast_nullable_to_non_nullable
as String,paymentHash: null == paymentHash ? _self.paymentHash : paymentHash // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class TransactionKind_LightningSend extends TransactionKind {
  const TransactionKind_LightningSend({required this.fees, required this.gateway, required this.paymentHash, required this.preimage, this.lnAddress}): super._();
  

 final  BigInt fees;
 final  String gateway;
 final  String paymentHash;
 final  String preimage;
 final  String? lnAddress;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_LightningSendCopyWith<TransactionKind_LightningSend> get copyWith => _$TransactionKind_LightningSendCopyWithImpl<TransactionKind_LightningSend>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_LightningSend&&(identical(other.fees, fees) || other.fees == fees)&&(identical(other.gateway, gateway) || other.gateway == gateway)&&(identical(other.paymentHash, paymentHash) || other.paymentHash == paymentHash)&&(identical(other.preimage, preimage) || other.preimage == preimage)&&(identical(other.lnAddress, lnAddress) || other.lnAddress == lnAddress));
}


@override
int get hashCode => Object.hash(runtimeType,fees,gateway,paymentHash,preimage,lnAddress);

@override
String toString() {
  return 'TransactionKind.lightningSend(fees: $fees, gateway: $gateway, paymentHash: $paymentHash, preimage: $preimage, lnAddress: $lnAddress)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_LightningSendCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_LightningSendCopyWith(TransactionKind_LightningSend value, $Res Function(TransactionKind_LightningSend) _then) = _$TransactionKind_LightningSendCopyWithImpl;
@useResult
$Res call({
 BigInt fees, String gateway, String paymentHash, String preimage, String? lnAddress
});




}
/// @nodoc
class _$TransactionKind_LightningSendCopyWithImpl<$Res>
    implements $TransactionKind_LightningSendCopyWith<$Res> {
  _$TransactionKind_LightningSendCopyWithImpl(this._self, this._then);

  final TransactionKind_LightningSend _self;
  final $Res Function(TransactionKind_LightningSend) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? fees = null,Object? gateway = null,Object? paymentHash = null,Object? preimage = null,Object? lnAddress = freezed,}) {
  return _then(TransactionKind_LightningSend(
fees: null == fees ? _self.fees : fees // ignore: cast_nullable_to_non_nullable
as BigInt,gateway: null == gateway ? _self.gateway : gateway // ignore: cast_nullable_to_non_nullable
as String,paymentHash: null == paymentHash ? _self.paymentHash : paymentHash // ignore: cast_nullable_to_non_nullable
as String,preimage: null == preimage ? _self.preimage : preimage // ignore: cast_nullable_to_non_nullable
as String,lnAddress: freezed == lnAddress ? _self.lnAddress : lnAddress // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

/// @nodoc


class TransactionKind_LightningRecurring extends TransactionKind {
  const TransactionKind_LightningRecurring(): super._();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_LightningRecurring);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionKind.lightningRecurring()';
}


}




/// @nodoc


class TransactionKind_OnchainReceive extends TransactionKind {
  const TransactionKind_OnchainReceive({required this.address, required this.txid}): super._();
  

 final  String address;
 final  String txid;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_OnchainReceiveCopyWith<TransactionKind_OnchainReceive> get copyWith => _$TransactionKind_OnchainReceiveCopyWithImpl<TransactionKind_OnchainReceive>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_OnchainReceive&&(identical(other.address, address) || other.address == address)&&(identical(other.txid, txid) || other.txid == txid));
}


@override
int get hashCode => Object.hash(runtimeType,address,txid);

@override
String toString() {
  return 'TransactionKind.onchainReceive(address: $address, txid: $txid)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_OnchainReceiveCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_OnchainReceiveCopyWith(TransactionKind_OnchainReceive value, $Res Function(TransactionKind_OnchainReceive) _then) = _$TransactionKind_OnchainReceiveCopyWithImpl;
@useResult
$Res call({
 String address, String txid
});




}
/// @nodoc
class _$TransactionKind_OnchainReceiveCopyWithImpl<$Res>
    implements $TransactionKind_OnchainReceiveCopyWith<$Res> {
  _$TransactionKind_OnchainReceiveCopyWithImpl(this._self, this._then);

  final TransactionKind_OnchainReceive _self;
  final $Res Function(TransactionKind_OnchainReceive) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? address = null,Object? txid = null,}) {
  return _then(TransactionKind_OnchainReceive(
address: null == address ? _self.address : address // ignore: cast_nullable_to_non_nullable
as String,txid: null == txid ? _self.txid : txid // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class TransactionKind_OnchainSend extends TransactionKind {
  const TransactionKind_OnchainSend({required this.address, required this.txid, this.feeRateSatsPerVb, this.txSizeVb, this.feeSats, this.totalSats}): super._();
  

 final  String address;
 final  String txid;
 final  double? feeRateSatsPerVb;
 final  int? txSizeVb;
 final  BigInt? feeSats;
 final  BigInt? totalSats;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_OnchainSendCopyWith<TransactionKind_OnchainSend> get copyWith => _$TransactionKind_OnchainSendCopyWithImpl<TransactionKind_OnchainSend>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_OnchainSend&&(identical(other.address, address) || other.address == address)&&(identical(other.txid, txid) || other.txid == txid)&&(identical(other.feeRateSatsPerVb, feeRateSatsPerVb) || other.feeRateSatsPerVb == feeRateSatsPerVb)&&(identical(other.txSizeVb, txSizeVb) || other.txSizeVb == txSizeVb)&&(identical(other.feeSats, feeSats) || other.feeSats == feeSats)&&(identical(other.totalSats, totalSats) || other.totalSats == totalSats));
}


@override
int get hashCode => Object.hash(runtimeType,address,txid,feeRateSatsPerVb,txSizeVb,feeSats,totalSats);

@override
String toString() {
  return 'TransactionKind.onchainSend(address: $address, txid: $txid, feeRateSatsPerVb: $feeRateSatsPerVb, txSizeVb: $txSizeVb, feeSats: $feeSats, totalSats: $totalSats)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_OnchainSendCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_OnchainSendCopyWith(TransactionKind_OnchainSend value, $Res Function(TransactionKind_OnchainSend) _then) = _$TransactionKind_OnchainSendCopyWithImpl;
@useResult
$Res call({
 String address, String txid, double? feeRateSatsPerVb, int? txSizeVb, BigInt? feeSats, BigInt? totalSats
});




}
/// @nodoc
class _$TransactionKind_OnchainSendCopyWithImpl<$Res>
    implements $TransactionKind_OnchainSendCopyWith<$Res> {
  _$TransactionKind_OnchainSendCopyWithImpl(this._self, this._then);

  final TransactionKind_OnchainSend _self;
  final $Res Function(TransactionKind_OnchainSend) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? address = null,Object? txid = null,Object? feeRateSatsPerVb = freezed,Object? txSizeVb = freezed,Object? feeSats = freezed,Object? totalSats = freezed,}) {
  return _then(TransactionKind_OnchainSend(
address: null == address ? _self.address : address // ignore: cast_nullable_to_non_nullable
as String,txid: null == txid ? _self.txid : txid // ignore: cast_nullable_to_non_nullable
as String,feeRateSatsPerVb: freezed == feeRateSatsPerVb ? _self.feeRateSatsPerVb : feeRateSatsPerVb // ignore: cast_nullable_to_non_nullable
as double?,txSizeVb: freezed == txSizeVb ? _self.txSizeVb : txSizeVb // ignore: cast_nullable_to_non_nullable
as int?,feeSats: freezed == feeSats ? _self.feeSats : feeSats // ignore: cast_nullable_to_non_nullable
as BigInt?,totalSats: freezed == totalSats ? _self.totalSats : totalSats // ignore: cast_nullable_to_non_nullable
as BigInt?,
  ));
}


}

/// @nodoc


class TransactionKind_EcashReceive extends TransactionKind {
  const TransactionKind_EcashReceive({required this.oobNotes, required this.fees}): super._();
  

 final  String oobNotes;
 final  BigInt fees;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_EcashReceiveCopyWith<TransactionKind_EcashReceive> get copyWith => _$TransactionKind_EcashReceiveCopyWithImpl<TransactionKind_EcashReceive>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_EcashReceive&&(identical(other.oobNotes, oobNotes) || other.oobNotes == oobNotes)&&(identical(other.fees, fees) || other.fees == fees));
}


@override
int get hashCode => Object.hash(runtimeType,oobNotes,fees);

@override
String toString() {
  return 'TransactionKind.ecashReceive(oobNotes: $oobNotes, fees: $fees)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_EcashReceiveCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_EcashReceiveCopyWith(TransactionKind_EcashReceive value, $Res Function(TransactionKind_EcashReceive) _then) = _$TransactionKind_EcashReceiveCopyWithImpl;
@useResult
$Res call({
 String oobNotes, BigInt fees
});




}
/// @nodoc
class _$TransactionKind_EcashReceiveCopyWithImpl<$Res>
    implements $TransactionKind_EcashReceiveCopyWith<$Res> {
  _$TransactionKind_EcashReceiveCopyWithImpl(this._self, this._then);

  final TransactionKind_EcashReceive _self;
  final $Res Function(TransactionKind_EcashReceive) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? oobNotes = null,Object? fees = null,}) {
  return _then(TransactionKind_EcashReceive(
oobNotes: null == oobNotes ? _self.oobNotes : oobNotes // ignore: cast_nullable_to_non_nullable
as String,fees: null == fees ? _self.fees : fees // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

/// @nodoc


class TransactionKind_EcashSend extends TransactionKind {
  const TransactionKind_EcashSend({required this.oobNotes, required this.fees}): super._();
  

 final  String oobNotes;
 final  BigInt fees;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TransactionKind_EcashSendCopyWith<TransactionKind_EcashSend> get copyWith => _$TransactionKind_EcashSendCopyWithImpl<TransactionKind_EcashSend>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionKind_EcashSend&&(identical(other.oobNotes, oobNotes) || other.oobNotes == oobNotes)&&(identical(other.fees, fees) || other.fees == fees));
}


@override
int get hashCode => Object.hash(runtimeType,oobNotes,fees);

@override
String toString() {
  return 'TransactionKind.ecashSend(oobNotes: $oobNotes, fees: $fees)';
}


}

/// @nodoc
abstract mixin class $TransactionKind_EcashSendCopyWith<$Res> implements $TransactionKindCopyWith<$Res> {
  factory $TransactionKind_EcashSendCopyWith(TransactionKind_EcashSend value, $Res Function(TransactionKind_EcashSend) _then) = _$TransactionKind_EcashSendCopyWithImpl;
@useResult
$Res call({
 String oobNotes, BigInt fees
});




}
/// @nodoc
class _$TransactionKind_EcashSendCopyWithImpl<$Res>
    implements $TransactionKind_EcashSendCopyWith<$Res> {
  _$TransactionKind_EcashSendCopyWithImpl(this._self, this._then);

  final TransactionKind_EcashSend _self;
  final $Res Function(TransactionKind_EcashSend) _then;

/// Create a copy of TransactionKind
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? oobNotes = null,Object? fees = null,}) {
  return _then(TransactionKind_EcashSend(
oobNotes: null == oobNotes ? _self.oobNotes : oobNotes // ignore: cast_nullable_to_non_nullable
as String,fees: null == fees ? _self.fees : fees // ignore: cast_nullable_to_non_nullable
as BigInt,
  ));
}


}

// dart format on
